алгоритм
Входные данные:
1. строка, от которой вычисляется хеш
2. длина строки
3. число фрагментов
4. состояние для функции keccak(м.б. null)
5. массив для хранения результата работы

Данные, которые используются в процессе работы:
1. a,b - 2 массива из 2 64-битных чисел 
2. state - состояние функции keccak state, в котором будут проходить вычисления.  При ненулевом входном параметре 5 инициализируется из него. Объект состояния состоит из объекта hash_state, массива k из 64 целых чисел, и массива init из 128 целых чисел (первоначальное состояние keccak?). Объект hash_state состоит из массива b из 200 целых чисел, и массива w из 25 64х-битных чисел.
3. registerA, registerB, registerC, registerAA, registerBB, registerKC, registerKB - 128-битные регистры SSE (необходимо заменить на независимую от платформы реализацию)
4. 64х-битные числа hi и lo для хранения результатов умножения регистров (старшие и младшие разряды)
5. round - индекс для подстановки из keccakf_rndc

Шаги:
1. Выделение памяти для хранения состояния keccak - инициализируется hp_state
Далее цикл по числу фрагментов:
2. Если переданный keccak_state равен NULL, инициализировать состояние keccak из переданной data, иначе загрузить в локальный state переданное состояние keccak
3. Применяется функция XOR между состоянием keccak и имеющимся хешем с использованием регистров registerA и registerB(2 раза): <-- необходим рефакторинг без привязки к аппаратной платформе
    в регистр registerA записывается содержимое хеша по индексу, равному текущему фрагменту*32 + 0 (во второй проход + 16)
    в регистр registerB записывается нулевой(во второй проход - 16) байт состояния keccak
    затем в registerB записывается результат операции XOR между registerB и registerA
    после этого к состоянию применяется функция keccakf
4. Для хранения ключа AES создаётся массив uint8 expandedKey размером 240. Для хранения пропущенного через функцию AES содержимого state.init создаётся массив text, равный по размеру state.init, в него копируется содержимое state.init
5. Результат применения AES к state.hs.b записывается в expandedKey. Ход применения AES(необходимо переписать в независимой от платформы форме):
    используются 128-битные регистры t1, t2, t3 и указатель ek для хранения результата в 128-битном формате
    ek инициализируется адресом expandedKey
    в t1 записывается state.hs.b[0]
    в t3 записывается state.hs.b[16]
    в ek[0] записывается t1, в ek[1] - t3
    4 раза применяется операция shuffleAes:
    в t2 записывается результат выполнения AES с данными из t3 и константами 1,2,4,8
    к регистрам t1 и t2 применяется операция aes_256_assist1:
        создаётся дополнительный временный регистр t4
        во второй регистр записывается результат перемешивания 4 32-хбитных частей этого же регистра по модулю 0xff
        в t4 записывается результат сдвига в t1 на 4 разряда
        Дважды:
            в первый регистр записывается результат xor между ним и t4
            в t4 записывается результат сдвига в нём же на 4 разряда
        в первый регистр записывается результат xor между ним и t4
        в первый регистр записывается результат xor между ним и вторым регистром
    в ek[2,4,6,8] записывается t1
    к регистрам t1 и t3 применяется операция aes_256_assist2:
        создаются дополнительные временные регистры t2 и t4
        в t4 записывается результат выполнения AES с данными из первого регистра и константой 0x00
        в t2 записывается результат перемешивания t4 по модулю 0xaa
        в t4 записывается результат сдвига разрядов во втором регистре на 4
        во второй регистр записывается результат применения xor к нему же и t4
        дважды:
            в t4 записывается результат сдвига разрядов в нём же на 4
            во второй регистр записывается результат применения xor к нему же и t4
        во второй регистр записывается результат применения xor к нему же и первому регистру
    в ek[3,5,7,9] записывается t3
    в t2 записывается результат применения AES к t3 с аргументом 10
    к t1 и t2 применяется операция aes_256_assist1 (см.выше)
    в ek[10] записывается t1
6. в каждый 128-байтный участок (блок hp_state) записывается результат применения AES к исходным данным state.init с ключом expandedKey. <-- необходим рефакторинг без привязки к платформе
    создаётся временный регистр d. В цикле по числу блоков (8) в него записывается содержимое state по адресу, равному счётчику + размер блока(16)
    после этого 10 раз к регистру применяется шифрование AES с аргументом, равным соответствующему символу ключа шифрования
7. в hp_state записывается state.hs
8. В массив a в первый элемент записывается результат операции xor между 0 элементом 0 элемента state.k и 0 элементом 32 элемента state.k. В массив a во второй элемент записывается результат операции xor между 1 элементом 0 элемента state.k и 1 элементом 32 элемента state.k. В массив b в первый элемент записывается результат операции xor между 0 элементом 16 элемента state.k и 0 элементом 48 элемента state.k. В массив a во второй элемент записывается результат операции xor между 1 элементом 16 элемента state.k и 1 элементом 48 элемента state.k
9. Из hash получается размер фрагмента:
    первый элемент хеша делится на 4294967296, полученное значение умножается на 2, от него отнимается 1, полученное значение умножается на 0.88235, от полученного значения берётся функция арктангенса, от него берётся экспонента и умножается на 1048576
10. во fragmentSizeDividedByEHP записывается результат деления нацело размера фрагмента на 1024, во fragmentPrecalc - остаток от деления размера фрагмента на 1024
11. в цикле от 0 до fragmentPrecalc происходит операция permutateHash:
    создаётся массив из 5 64-битных чисел bc
    создаётся массив из 2 64-битных чисел c
    вычисляется state_index от a
    в registerC записывается элемент hp_state по найденному индексу
    в registerKC записывается элемент hp_state по keccak_index от a
    в registerC записывается результат операции xor между registerC и registerKC
    в registerA записывается значение a
    в registerC записывается результат применения AES к нему же с round = registerA
    значение registerC сохраняется в c
    в registerB записывается xor от него же и registerC
    в registerKB записывается xor от registerB и registerKC
    в значение состояния hp_state по индексу state_index записывается registerB
    в значение состояния hp_state по индексу keccak_index от c записывается registerKB
    вычисляется state_index от c
    берётся указатель p на значение hp_state c вычисленным индексом
    в b копируется p
    b и c перемножаются //не удалось найти объявления mul
    для дальнейших вычислений применяются функции theta, rho pi, chi, iota
12. Аналогично в двойном цикле от 0 до fragmentSizeDividedByEHP и от 0 до 1024 происходит операция permutateHash
13. extra_hashes[state.hs.b[0] & 3](&state, 200, &hash[fragments*32]); // непонятно, что здесь происходит
14. повторяется шаг 3, но уже для всего hp_state, а не только state.hs.
15. вывод результатов, освобождение памяти.

Вывод: рефакторинг с условной компиляцией аппаратно-зависимых фрагментов требуется, чтобы заменить переменные 3, + заменить на независимую от платформы форму на шагах 3, 5, 6, 11, 12, 14
    
    
    
        
